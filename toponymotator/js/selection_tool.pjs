var fEditBase, fEditBox;
var basePath;
var box;

reset();

function reset() {
  fEditBase = true;
  fEditBox = false;

  basePath = new Path();
  basePath.strokeColor = '#aa0000';
  basePath.strokeWidth = 3;
}

function onMouseDown(event) {
  if (fEditBase) {
    if (basePath.segments.length == 0) {
      basePath.add(event.point);
      var start = new Path.Circle(event.point, 4);
      start.fillColor = '#aa0000';
    }

    basePath.add(event.point);
  }
}

function onMouseDrag(event) {
  if (fEditBase) {
    basePath.lastSegment.point = event.point;   
  }
}

function onMouseMove(event) {
  if (fEditBox) {
    // Shortcuts for basepath start (A) and end point (B)
    var A = basePath.segments[0].point;
    var B = basePath.segments[1].point;

    // Baseline vector (start to end)
    var delta = B - A;

    // Slope of the baseline normal
    var normal = new Point(delta.y * -1, delta.x).normalize();

    // Vector B -> Mouse
    var toMouse = event.point - B;

    // Projection of toMouse onto normal
    var f = normal * toMouse.length * Math.cos(normal.getAngleInRadians(toMouse));

    // Draw box outline
    box.segments[2].point = new Point(B.x + f.x, B.y + f.y);
    box.segments[3].point = new Point(A.x + f.x, A.y + f.y);
  }
}

function onMouseUp(event) {
  if (fEditBase) {
    fEditBase = false;
    fEditBox = true;
    box = new Path();
    box.segments = basePath.segments;
    box.add(basePath.lastSegment.point);
    box.add(basePath.segments[0].point);
    box.add(basePath.segments[0].point);
    box.fillColor = '#aa0000';
    box.opacity = 0.2;
  } else if (fEditBox) {
    reset();
  }
}

